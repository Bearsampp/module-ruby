/*
 * Bearsampp Module Ruby - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=3.4.5      - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'ruby')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'ruby')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'tools')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // External build base path precedence: build.properties (build.path) -> env(BEARSAMPP_BUILD_PATH) -> default <root>/bearsampp-build
    def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"
    buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

    // Shared external tmp tree
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpSrcPath = file("${buildTmpPath}/bundles_src").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath

    // Final external output path for archives (e.g., bearsampp-build/tools/ruby/2025.8.16)
    moduleBuildOutputPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// GRADLE NATIVE TASKS - Pure Gradle Implementation
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time to avoid deprecation warnings
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module Ruby - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Base:   ${buildBasePath}
          Output Dir:   ${moduleBuildOutputPath}
          Tmp Root:     ${buildTmpPath}
          Tmp Prep:     ${bundleTmpPrepPath}
          Tmp Build:    ${bundleTmpBuildPath}
          Tmp Src:      ${bundleTmpSrcPath}
          Downloads:    ${bundleTmpDownloadPath}
          Extract:      ${bundleTmpExtractPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                          - List all available tasks
          gradle info                           - Show this information
          gradle release                        - Interactive release build
          gradle release -PbundleVersion=3.4.5  - Non-interactive release
          gradle clean                          - Clean build artifacts
          gradle verify                         - Verify build environment
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories except bundles_build (preserve uncompressed versions)
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            // Clean specific subdirectories but preserve bundles_build
            ['bundles_prep', 'bundles_src', 'downloads', 'extract'].each { subdir ->
                def subdirPath = file("${buildTmpPath}/${subdir}")
                if (subdirPath.exists()) {
                    delete subdirPath
                    println "Cleaned: ${subdirPath}"
                }
            }
        }

        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned: ${gradleBundleVersion.name}"
        }

        println "[SUCCESS] Build artifacts cleaned (bundles_build preserved)"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-ruby..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                        - Interactive release"
            println "  gradle release -PbundleVersion=3.4.5  - Non-interactive release"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper function to find 7-Zip executable
def find7ZipExecutable() {
    // Check environment variable
    def sevenZipHome = System.getenv('7Z_HOME')
    if (sevenZipHome) {
        def exe = file("${sevenZipHome}/7z.exe")
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Check common installation paths
    def commonPaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        'D:/Program Files/7-Zip/7z.exe',
        'D:/Program Files (x86)/7-Zip/7z.exe'
    ]

    for (path in commonPaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = ['where', '7z.exe'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def output = process.text.trim()
            if (output) {
                return output.split('\n')[0].trim()
            }
        }
    } catch (Exception e) {
        // Ignore
    }

    return null
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper: Fetch ruby.properties from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/ruby.properties"

    println "Fetching ruby.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"

    def tempFile = file("${bundleTmpDownloadPath}/ruby-untouched.properties")
    tempFile.parentFile.mkdirs()

    try {
        // Download using Java URL connection
        new URL(propsUrl).withInputStream { input ->
            tempFile.withOutputStream { output ->
                output << input
            }
        }

        def props = new Properties()
        tempFile.withInputStream { props.load(it) }

        println "  [OK] Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  [WARNING] Could not fetch ruby.properties from modules-untouched: ${e.message}"
        println "  Will fall back to standard URL format if needed"
        return null
    }
}

// Helper: Download Ruby binaries from modules-untouched repository
def downloadFromModulesUntouched(String version, File destDir) {
    def untouchedProps = fetchModulesUntouchedProperties()
    def untouchedUrl = null

    if (untouchedProps) {
        untouchedUrl = untouchedProps.getProperty(version)
        if (untouchedUrl) {
            println "Found version ${version} in modules-untouched ruby.properties"
            println "Downloading from:"
            println "  ${untouchedUrl}"
        } else {
            println "Version ${version} not found in modules-untouched ruby.properties"
            println "Attempting to construct URL based on standard format..."
            // Fallback to constructed URL - RubyInstaller format
            untouchedUrl = "https://github.com/oneclick/rubyinstaller2/releases/download/RubyInstaller-${version}/rubyinstaller-${version}-x64.7z"
            println "  ${untouchedUrl}"
        }
    } else {
        println "Could not fetch ruby.properties, using standard URL format..."
        // Fallback to constructed URL
        untouchedUrl = "https://github.com/oneclick/rubyinstaller2/releases/download/RubyInstaller-${version}/rubyinstaller-${version}-x64.7z"
        println "  ${untouchedUrl}"
    }

    // Determine filename from URL
    def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
    def downloadDir = file(bundleTmpDownloadPath)
    downloadDir.mkdirs()

    def downloadedFile = file("${downloadDir}/${filename}")

    // Download if not already present
    if (!downloadedFile.exists()) {
        println "  Downloading..."
        new URL(untouchedUrl).withInputStream { input ->
            downloadedFile.withOutputStream { output ->
                output << input
            }
        }
        println "  [OK] Downloaded: ${downloadedFile.name}"
    } else {
        println "  [OK] Already downloaded: ${downloadedFile.name}"
    }

    return downloadedFile
}

// Helper: Download and extract Ruby binaries
def downloadAndExtractRuby(String version, File destDir) {
    // Download from modules-untouched
    def downloadedFile = downloadFromModulesUntouched(version, destDir)

    // Extract the archive
    def extractDir = file(bundleTmpExtractPath)
    extractDir.mkdirs()
    println "  Extracting archive..."
    def extractPath = file("${extractDir}/${version}")
    if (extractPath.exists()) {
        delete extractPath
    }
    extractPath.mkdirs()

    // Extract using 7-Zip
    def sevenZipExe = find7ZipExecutable()
    if (!sevenZipExe) {
        throw new GradleException("7-Zip not found. Cannot extract .7z archive: ${downloadedFile.name}")
    }

    def command = [
        sevenZipExe,
        'x',
        downloadedFile.absolutePath,
        "-o${extractPath.absolutePath}",
        '-y'
    ]

    def process = new ProcessBuilder(command as String[])
        .redirectErrorStream(true)
        .start()

    def output = new StringBuilder()
    process.inputStream.eachLine { line ->
        output.append(line).append('\n')
    }

    def exitCode = process.waitFor()
    if (exitCode != 0) {
        throw new GradleException("7-Zip extraction failed with exit code: ${exitCode}\nOutput: ${output}")
    }

    // Find the Ruby directory (it might be nested)
    def rubyDir = findRubyDirectory(extractPath)
    if (!rubyDir) {
        throw new GradleException("Could not find Ruby directory in extracted archive")
    }

    println "  Extracted to: ${rubyDir}"
    return rubyDir
}

// Helper: Find Ruby directory containing ruby.exe
def findRubyDirectory(File searchDir) {
    // Case 1: Check if ruby.exe is directly in bin subdirectory
    def binDir = new File(searchDir, 'bin')
    if (binDir.exists()) {
        def rubyExe = new File(binDir, 'ruby.exe')
        if (rubyExe.exists()) {
            return searchDir
        }
    }

    // Case 2: Recursively search for a directory containing bin/ruby.exe
    File found = null
    def stack = new ArrayDeque<File>()
    stack.push(searchDir)

    while (!stack.isEmpty() && !found) {
        def current = stack.pop()
        def children = current.listFiles()
        if (children) {
            for (def child : children) {
                if (child.isDirectory()) {
                    def childBin = new File(child, 'bin')
                    if (childBin.exists()) {
                        def exe = new File(childBin, 'ruby.exe')
                        if (exe.exists()) {
                            found = child
                            break
                        }
                    }
                    stack.push(child)
                }
            }
        }
    }

    return found
}

// Task: Download file helper
def downloadFile(String url, File destDir) {
    if (!url) {
        throw new GradleException("Download URL is null or empty")
    }

    def fileName = url.tokenize('/').last()
    def destFile = new File(destDir, fileName)

    if (!destFile.exists()) {
        println "Downloading: ${url}"
        destFile.parentFile.mkdirs()

        new URL(url).withInputStream { input ->
            destFile.withOutputStream { output ->
                output << input
            }
        }
        println "Downloaded to: ${destFile}"
    } else {
        println "Already exists: ${destFile}"
    }

    return destFile
}

// Helper methods for version discovery and selection
def findAvailableVersions = {
    def binDir = new File(projectDir, 'bin')
    def archivedDir = new File(projectDir, 'bin/archived')
    def versions = [] as List<String>

    if (binDir.exists()) {
        versions.addAll(
            (binDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    if (archivedDir.exists()) {
        versions.addAll(
            (archivedDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    return versions.unique()
}

def latestVersion = { List<String> versions ->
    if (versions.isEmpty()) return null
    // Compare numerically by dot-separated parts
    return versions.max { a, b ->
        def pa = a.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
        def pb = b.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
        def len = Math.max(pa.size(), pb.size())
        for (int i = 0; i < len; i++) {
            def ai = i < pa.size() ? pa[i] : 0
            def bi = i < pb.size() ? pb[i] : 0
            if (ai != bi) return ai <=> bi
        }
        return 0
    }
}

// Task: Resolve version (interactive by default; supports -PbundleVersion and '*')
tasks.register('resolveVersion') {
    group = 'build'
    description = 'Resolve bundleVersion (interactive by default, or use -PbundleVersion=*,<ver>)'

    // Capture properties at configuration time
    def versionProperty = project.findProperty('bundleVersion')
    def projectDirPath = projectDir
    def bundleNameValue = bundleName

    doLast {
        def supplied = versionProperty as String
        // Aggregate both bin/ and bin/archived/ and display with location tags
        def all = findAvailableVersions().sort { a, b ->
            def pa = a.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
            def pb = b.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
            for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }
        def inBin = new File(projectDir, 'bin').exists() ? (new File(projectDir, 'bin').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []
        def inArchived = new File(projectDir, 'bin/archived').exists() ? (new File(projectDir, 'bin/archived').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        String resolved
        if (supplied) {
            if (supplied == '*') {
                resolved = latestVersion(all)
                if (!resolved) {
                    throw new GradleException("No versions found under bin/ to resolve latest from.")
                }
                println "Resolved latest version: ${resolved}"
            } else {
                resolved = supplied
            }
        } else {
            println "=".multiply(70)
            println "Available ${bundleName} versions (index, version, location):"
            println "-".multiply(70)
            all.eachWithIndex { v, idx ->
                def indexStr = String.format('%2d', idx + 1)
                def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
                println "  ${indexStr}. ${v.padRight(12)} ${tag}"
            }
            println "-".multiply(70)
            print "\nEnter version to build (index or version string): "
            System.out.flush()
            def reader = new BufferedReader(new InputStreamReader(System.in))
            def input = reader.readLine()?.trim()
            if (!input) {
                throw new GradleException("No version specified")
            }
            if (input.isInteger()) {
                def idx = input.toInteger()
                if (idx < 1 || idx > all.size()) {
                    throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
                }
                resolved = all[idx - 1]
            } else {
                resolved = input
            }
        }

        // Validate existence in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${resolved}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${resolved}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${resolved}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose to subsequent tasks as extra property
        // Store in a shared location that can be accessed by other tasks
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        propsFile.parentFile.mkdirs()
        propsFile.text = resolved
        println "\nSelected version: ${resolved}\n"
    }
}

// Task: Main release task (interactive by default; non‑interactive when -PbundleVersion provided)
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive by default; -PbundleVersion=* or X.Y.Z for non-interactive)'

    // Always clean before building to ensure fresh build
    dependsOn 'clean', 'resolveVersion', 'packageRelease'
}

// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'
    dependsOn 'resolveVersion'

    // Capture version at configuration time to avoid deprecation warnings
    def versionProvider = providers.provider {
        def fromProp = project.findProperty('bundleVersion') as String
        if (fromProp) return fromProp
        // Read from file written by resolveVersion task
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        if (propsFile.exists()) {
            return propsFile.text.trim()
        }
        return null
    }

    doLast {
        def versionToBuild = versionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Resolve config folder from bin/ or bin/archived/ (contains rubygems/, bearsampp.conf, etc.)
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}")
            }
        }

        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "Processing bundle: ${bundleFolder}"
        println "Version: ${bundleVersion}"

        // Determine source paths for Ruby binaries
        def bundleSrcDest = bundlePath
        def bundleSrcFinal = bundleSrcDest

        // Check if ruby.exe exists in bin/ directory (it won't - only config files are there)
        def rubyExe = file("${bundleSrcFinal}/bin/ruby.exe")
        if (!rubyExe.exists()) {
            // Ruby binaries not found in bin/ - check if already downloaded to bearsampp-build/tmp
            def tmpExtractPath = file("${bundleTmpExtractPath}/${bundleVersion}")
            def tmpRubyDir = findRubyDirectory(tmpExtractPath)

            if (tmpRubyDir && tmpRubyDir.exists()) {
                println "Using cached Ruby binaries from bearsampp-build/tmp"
                bundleSrcFinal = tmpRubyDir
            } else {
                // Download and extract to bearsampp-build/tmp
                println ""
                println "Ruby binaries not found"
                println "Downloading Ruby ${bundleVersion}..."
                println ""

                try {
                    // Download and extract to bearsampp-build/tmp
                    bundleSrcFinal = downloadAndExtractRuby(bundleVersion, file(bundleTmpExtractPath))
                } catch (Exception e) {
                    throw new GradleException("""
                        Failed to download Ruby binaries: ${e.message}

                        You can manually download and extract Ruby binaries to:
                          ${bundleSrcDest}/

                        Or check that version ${bundleVersion} exists in modules-untouched ruby.properties
                    """.stripIndent())
                }
            }
        }

        // Verify ruby.exe exists
        rubyExe = file("${bundleSrcFinal}/bin/ruby.exe")
        if (!rubyExe.exists()) {
            throw new GradleException("ruby.exe not found at ${rubyExe}")
        }

        println "Source folder: ${bundleSrcFinal}"
        println ""

        // Prepare Ruby directory
        def rubyPrepPath = new File(bundleTmpPrepPath, bundleFolder)
        delete rubyPrepPath
        rubyPrepPath.mkdirs()

        println "Preparation path: ${rubyPrepPath}"

        // Copy base Ruby binaries
        println "Copying base Ruby files..."
        copy {
            from bundleSrcFinal
            into rubyPrepPath
        }

        // Copy config files from bin/ directory (bearsampp.conf, etc.)
        println "Copying configuration files..."
        copy {
            from bundleSrcDest
            into rubyPrepPath
            exclude 'rubygems/**'
        }

        // Process RubyGems if rubygems/ directory exists
        def rubygemsDir = new File(bundlePath, 'rubygems')
        if (rubygemsDir.exists()) {
            println "Processing RubyGems installation..."
            processRubyGems(rubygemsDir, rubyPrepPath)
        }

        // Update paths in Ruby scripts
        println "Updating paths in Ruby scripts..."
        updateRubyPaths(rubyPrepPath, bundleVersion)

        // Copy prepared files to bundles_build directory for reference
        def bundleBuildPath = new File(bundleTmpBuildPath, bundleFolder)
        println ""
        println "Copying to build output directory..."
        delete bundleBuildPath
        bundleBuildPath.mkdirs()
        copy {
            from rubyPrepPath
            into bundleBuildPath
        }
        println "Build output: ${bundleBuildPath}"

        // Store the build output path for reference in final message
        // Write to a file instead of using task extensions (deprecated in Gradle 9+)
        def buildInfoFile = file("${buildTmpPath}/.gradle-buildInfo")
        buildInfoFile.parentFile.mkdirs()
        buildInfoFile.text = "${bundleBuildPath.absolutePath}\n${rubyPrepPath.absolutePath}"
    }
}

// Helper: Process RubyGems installation
def processRubyGems(File rubygemsDir, File rubyPrepPath) {
    // Read rubygems.properties
    def rubygemsProps = new File(rubygemsDir, 'rubygems.properties')
    if (!rubygemsProps.exists()) {
        println "  [WARNING] rubygems.properties not found"
        return
    }

    def props = new Properties()
    rubygemsProps.withInputStream { props.load(it) }

    def rubygemsUrl = props.getProperty('rubygems')
    if (!rubygemsUrl) {
        println "  [WARNING] RubyGems URL not found in rubygems.properties"
        return
    }

    // Create rubygems directory in prep path
    def rubygemsPrepDir = new File(rubyPrepPath, 'rubygems')
    rubygemsPrepDir.mkdirs()

    // Copy install.bat
    def installBat = new File(rubygemsDir, 'install.bat')
    if (installBat.exists()) {
        copy {
            from installBat
            into rubygemsPrepDir
        }
    }

    // Download RubyGems
    println "  Downloading RubyGems from: ${rubygemsUrl}"
    def rubygemsGem = downloadFile(rubygemsUrl, rubygemsPrepDir)

    // Rename to rubygems-update.gem if needed
    def targetGem = new File(rubygemsPrepDir, 'rubygems-update.gem')
    if (rubygemsGem.name != 'rubygems-update.gem') {
        rubygemsGem.renameTo(targetGem)
    }

    // Execute install.bat
    println "  Installing RubyGems..."
    def installBatPath = new File(rubygemsPrepDir, 'install.bat')
    if (installBatPath.exists()) {
        def command = ['cmd', '/c', installBatPath.absolutePath]
        def process = new ProcessBuilder(command as String[])
            .directory(rubygemsPrepDir)
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            println "    ${line}"
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("RubyGems installation failed with exit code: ${exitCode}")
        }
    }

    // Verify update_rubygems.bat exists
    def updateRubygemsBat = new File(rubyPrepPath, 'bin/update_rubygems.bat')
    if (!updateRubygemsBat.exists()) {
        println "  [WARNING] update_rubygems.bat not found after installation"
    } else {
        // Update RubyGems
        println "  Updating RubyGems..."
        def command = ['cmd', '/c', updateRubygemsBat.absolutePath]
        def process = new ProcessBuilder(command as String[])
            .directory(new File(rubyPrepPath, 'bin'))
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            println "    ${line}"
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            println "  [WARNING] RubyGems update failed with exit code: ${exitCode}"
        }

        // Check RubyGems version
        println "  Checking RubyGems version..."
        def gemBat = new File(rubyPrepPath, 'bin/gem.bat')
        if (gemBat.exists()) {
            def versionCommand = ['cmd', '/c', gemBat.absolutePath, '--version']
            def versionProcess = new ProcessBuilder(versionCommand as String[])
                .directory(new File(rubyPrepPath, 'bin'))
                .redirectErrorStream(true)
                .start()

            versionProcess.inputStream.eachLine { line ->
                println "    RubyGems version: ${line}"
            }

            versionProcess.waitFor()
        }
    }

    // Clean up rubygems directory
    delete rubygemsPrepDir
    println "  RubyGems installation completed"
}

// Helper: Update paths in Ruby scripts
def updateRubyPaths(File rubyPrepPath, String bundleVersion) {
    def binDir = new File(rubyPrepPath, 'bin')
    if (!binDir.exists()) {
        println "  [WARNING] bin directory not found"
        return
    }

    // Replace paths in all files in bin directory (excluding .dll and .exe)
    binDir.listFiles().each { file ->
        if (file.isFile() && !file.name.endsWith('.dll') && !file.name.endsWith('.exe')) {
            try {
                def content = file.text
                def originalPath = rubyPrepPath.absolutePath.replace('\\', '/')
                def bearsamppPath = "~BEARSAMPP_LIN_PATH~/tools/ruby/ruby${bundleVersion}"

                // Replace Windows-style paths
                content = content.replaceAll(originalPath.replaceAll('/', '\\\\'), bearsamppPath)
                // Replace Unix-style paths
                content = content.replaceAll(originalPath, bearsamppPath)
                // Replace any remaining absolute paths
                content = content.replaceAll(rubyPrepPath.absolutePath.replaceAll('\\\\', '\\\\\\\\'), bearsamppPath)

                file.text = content
            } catch (Exception e) {
                // Skip binary files or files that can't be read as text
                println "  [DEBUG] Skipping file: ${file.name} (${e.message})"
            }
        }
    }

    println "  Updated paths in Ruby scripts"
}

// Task: Package release as archive (ensures the version folder is included at archive root)
// Provider resolves version from either -PbundleVersion or value set by resolveVersion
def bundleVersionProvider = providers.provider {
    def fromProp = project.findProperty('bundleVersion') as String
    if (fromProp) return fromProp
    // Read from file written by resolveVersion task
    def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
    if (propsFile.exists()) {
        return propsFile.text.trim()
    }
    return null
}
def externalOutputDir = file("${moduleBuildOutputPath}")

// Guard task: ensure bundleVersion is resolved before any packaging runs
tasks.register('assertVersionResolved') {
    group = 'build'
    description = 'Fail fast if bundleVersion was not resolved by resolveVersion'
    dependsOn 'resolveVersion'
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set. Run 'gradle resolveVersion' or invoke 'gradle release -PbundleVersion=<'*'|X.Y.Z>'")
        }
    }
}

// 7z packager (uses ProcessBuilder pattern)
tasks.register('packageRelease7z') {
    group = 'build'
    description = 'Package release into a .7z archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared ruby directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        externalOutputDir.mkdirs()
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.7z"
        def archiveFile = new File(externalOutputDir, archiveName)

        // Delete existing archive if present
        if (archiveFile.exists()) {
            delete archiveFile
        }

        println "Packaging (7z): ${archiveFile}"
        println "Included root folder: ${bundleFolder}/"

        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("""
                7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.

                Download from: https://www.7-zip.org/
                Or set 7Z_HOME to your 7-Zip installation directory.
            """.stripIndent())
        }

        // Create 7z archive using ProcessBuilder
        def command = [
            sevenZipExe,
            'a',
            '-t7z',
            archiveFile.absolutePath.toString(),
            bundleFolder
        ]

        def process = new ProcessBuilder(command as String[])
            .directory(prepRoot)
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            if (line.trim()) println "  ${line}"
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip compression failed with exit code: ${exitCode}")
        }

        println "Archive created: ${archiveFile}"
    }
}

// Zip packager (Gradle native Zip task) — used if bundle.format != 7z
tasks.register('packageReleaseZip', Zip) {
    group = 'build'
    description = 'Package release into a .zip archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared ruby directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        archiveFileName.set("bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.zip")
        destinationDirectory.set(externalOutputDir)

        // Include the version folder as the top-level entry in the archive
        from(prepRoot) {
            include "${bundleFolder}/**"
        }

        println "Packaging (zip): ${new File(externalOutputDir, archiveFileName.get()).absolutePath}"
        println "Included root folder: ${bundleFolder}/"
    }
}

// Dispatcher task that chooses packager based on bundle.format
def archiveFormat = (bundleFormat ?: '7z').toLowerCase()
tasks.register('packageRelease') {
    group = 'build'
    description = 'Package release into archive (7z or zip) including the version folder at root'
    // Ensure the preparation step runs before packaging
    dependsOn 'resolveVersion', 'releaseBuild', 'assertVersionResolved'
    // Select the concrete packager at configuration time based on build.properties
    dependsOn archiveFormat == '7z' ? 'packageRelease7z' : 'packageReleaseZip'
}

// Task: Generate hash files for the produced archive (.md5, .sha1, .sha256, .sha512)
tasks.register('generateHashes') {
    group = 'build'
    description = 'Generate hash sidecar files for the packaged archive'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }
        def extFormat = (bundleFormat ?: '7z').toLowerCase()
        def archive = new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${extFormat}")
        if (!archive.exists()) {
            throw new GradleException("Archive not found for hashing: ${archive}")
        }

        def calcHash = { File f, String algorithm ->
            def digest = java.security.MessageDigest.getInstance(algorithm)
            f.withInputStream { stream ->
                byte[] buf = new byte[8192]
                int r
                while ((r = stream.read(buf)) != -1) {
                    digest.update(buf, 0, r)
                }
            }
            digest.digest().collect { String.format('%02x', it) }.join('')
        }

        def writeHash = { String algo, String ext ->
            def h = calcHash(archive, algo)
            def out = new File(archive.absolutePath + ".${ext}")
            out.text = "${h} ${archive.name}\n"
            println "Created: ${out.name}"
        }

        writeHash('MD5', 'md5')
        writeHash('SHA-1', 'sha1')
        writeHash('SHA-256', 'sha256')
        writeHash('SHA-512', 'sha512')

        // Print final success message matching the required format
        println ""
        println "=".multiply(70)
        println ""
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println ""
        println "Output directory: ${file("${bundleTmpBuildPath}/${bundleName}${versionToBuild}").absolutePath}"
        println ""
        println "Archive: ${archive.absolutePath}"
        println ""
        println "=".multiply(70)
    }
}

// Ensure hashes are generated after packaging during release, and cleanup temp files
tasks.named('release') {
    finalizedBy 'generateHashes', 'cleanupTempFiles'
}

// Task: Cleanup temporary Gradle-specific files after build
tasks.register('cleanupTempFiles') {
    group = 'build'
    description = 'Cleanup temporary Gradle-specific files after build'

    doLast {
        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned up: ${gradleBundleVersion.name}"
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable Ruby Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def inBin = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []

        def inArchived = archivedDir.exists() ? (archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        def allVersions = (inBin + inArchived).toSet().toList().sort { a, b ->
            def pa = a.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
            def pb = b.split(/[.\-]/).collect { it.isInteger() ? it as int : 0 }
            for (int i = 0; i < Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }

        println "\nAvailable ${bundleName} versions (index, version, location):"
        println "-".multiply(60)
        allVersions.eachWithIndex { v, idx ->
            def tag
            def inBinFlag = inBin.contains(v)
            def inArchivedFlag = inArchived.contains(v)
            if (inBinFlag && inArchivedFlag) {
                tag = "[bin + bin/archived]"
            } else if (inBinFlag) {
                tag = "[bin]"
            } else if (inArchivedFlag) {
                tag = "[bin/archived]"
            } else {
                tag = "[unknown]"
            }
            def indexStr = String.format('%2d', idx + 1)
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(60)
        println "Total versions: ${allVersions.size()}"
        if (!allVersions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${allVersions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: Show Ruby-specific build information
tasks.register('rubyInfo') {
    group = 'help'
    description = 'Display Ruby-specific build information'

    doLast {
        println """
        ================================================================
                  Ruby Module Build - Specific Information
        ================================================================

        This module includes special build processes for:

        1. RubyGems Installation (rubygems/)
           - Downloads and installs RubyGems package manager
           - Updates RubyGems to the latest version
           - Verifies installation

        2. Path Updates
           - Replaces absolute paths with Bearsampp placeholders
           - Updates all Ruby scripts in bin/ directory
           - Ensures portability across installations

        Configuration Files:
          - rubygems/rubygems.properties : RubyGems download URL
          - rubygems/install.bat         : Installation script
          - bearsampp.conf               : Bearsampp configuration

        Useful Commands:
          gradle listVersions       - Show available Ruby versions
          gradle listReleases       - Show releases from releases.properties
          gradle verify             - Verify build environment
        """.stripIndent()
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module Ruby - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
